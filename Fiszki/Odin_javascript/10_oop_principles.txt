Co to jest Zasada Pojedynczej Odpowiedzialności (Single Responsibility Principle - SRP)?;Mówi ona, że klasa (obiekt, moduł) powinna mieć tylko jedną odpowiedzialność, co oznacza, że powinna mieć tylko **jeden powód do zmiany**. 
Dlaczego mieszanie logiki aplikacji (np. sprawdzania warunku końca gry) z manipulacją DOM w jednej funkcji łamie zasadę SRP?;Ponieważ funkcja ma wtedy dwie odpowiedzialności: obliczanie stanu gry ORAZ aktualizację interfejsu użytkownika. Należy to rozdzielić na dwa niezależne moduły.
Czym są "ściśle powiązane" (tightly coupled) obiekty?;To obiekty, które tak mocno na sobie polegają (wiedzą o sobie za dużo), że zmiana lub usunięcie jednego z nich wymusza całkowitą przebudowę drugiego. 
Jaka jest główna zaleta tworzenia "luźno powiązanych" (loosely coupled) obiektów w aplikacji?;Pozwalają na łatwe i bezpieczne modyfikacje. Na przykład można całkowicie zmienić sposób działania interfejsu użytkownika (UI/DOM) bez konieczności dotykania i psucia głównej logiki biznesowej (np. zasad gry).
Czym jest akronim SOLID?;To zestaw pięciu podstawowych zasad projektowania zorientowanego obiektowo (OOP), pomagających w tworzeniu łatwiejszego w utrzymaniu i skalowaniu kodu. Pierwszą z nich jest Single Responsibility (S). 
Zgodnie z popularnymi i nowoczesnymi wzorcami projektowymi, co jest zazwyczaj preferowane: Kompozycja (Composition) czy Dziedziczenie (Inheritance)?;Zazwyczaj preferowana jest **Kompozycja** (favoring composition over inheritance), ponieważ budowanie obiektów z mniejszych, niezależnych części zapewnia większą elastyczność i pozwala uniknąć problemów ze sztywnymi, głębokimi łańcuchami dziedziczenia.
Na czym polega **Dziedziczenie (Inheritance)** w programowaniu obiektowym i jaką relację opisuje?;Tworzy nową klasę na bazie istniejącej (przejmując jej metody i właściwości). Opisuje relację **"jest czymś" (is-a)**.<br><br>Przykład: `class Dog extends Animal { ... }` (Pies *jest* zwierzęciem). 
Na czym polega **Kompozycja (Composition)** w programowaniu obiektowym i jaką relację opisuje?;Polega na budowaniu złożonych obiektów poprzez wstrzykiwanie mniejszych, niezależnych części (komponentów). Opisuje relację **"ma coś / składa się z" (has-a)**.<br><br>Przykład: `class Car { constructor() { this.engine = new Engine(); } }` (Samochód *ma* silnik). 
Jaki klasyczny problem z dziedziczeniem jest często określany jako problem "Goryla i Banana" (Gorilla Banana problem)?;Problem polega na tym, że potrzebujesz tylko jednej prostej funkcjonalności (banana), ale zmuszony do dziedziczenia otrzymujesz "goryla trzymającego banana i całą dżunglę" (ogromny, niepotrzebny bagaż stanu i metod z klas bazowych).
Dlaczego główna zasada projektowa brzmi: **"Preferuj kompozycję ponad dziedziczenie"** (Favor composition over inheritance)?;Ponieważ kompozycja jest znacznie **bardziej elastyczna**. Pozwala przypisywać i wymieniać zachowania w trakcie działania programu (runtime) oraz pozwala uniknąć sztywnych, kruchych i skomplikowanych łańcuchów hierarchii (compile-time). 
Czym jest **Problem Diamentu** (Diamond Problem) związany z dziedziczeniem wielokrotnym?;To konflikt, który pojawia się, gdy klasa `D` dziedziczy po klasach `B` i `C`, a obie te klasy dziedziczą po klasie `A` (i modyfikują jej metodę). Nie wiadomo, którą wersję metody klasa `D` powinna odziedziczyć.<br><br>Kompozycja rozwiązuje ten problem, ponieważ bezpośrednio określamy, jakich komponentów używa obiekt. 
Jak zaimplementować kompozycję w JavaScript używając Factory Functions zamiast klas? (Podaj przykład implementacji Kaczki, która umie pływać i latać);Tworząc osobne obiekty z zachowaniami i łącząc je przy użyciu `Object.assign`.<br><br>Przykład:<br><code>const canFly = () => ({ fly: () => 'Lecę' });</code><br><code>const canSwim = () => ({ swim: () => 'Pływam' });</code><br><code>const createDuck = () => Object.assign({}, canFly(), canSwim());</code>
W jakim scenariuszu dziedziczenie nadal ma sens i jest poprawne?;Dziedziczenie jest poprawne, gdy relacja **"is-a" (jest czymś)** jest całkowicie prawdziwa i stabilna w każdym możliwym przypadku, a klasa bazowa nie ma skłonności do częstych zmian (np. `class Button extends HTMLElement`).
