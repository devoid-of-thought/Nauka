Dlaczego JavaScript potrzebuje funkcji asynchronicznych (asynchronous functions)?;Ponieważ niektóre operacje (np. pobieranie danych z serwera) zajmują dużo czasu, a funkcje asynchroniczne pozwalają na ich wykonywanie w tle, nie blokując reszty działającego kodu.
Co to jest **Callback** (funkcja wywołania zwrotnego)?;To funkcja przekazywana do innej funkcji jako argument, która jest następnie wywoływana wewnątrz tej funkcji zewnętrznej w celu wykonania jakiejś akcji (np. funkcja reagująca na kliknięcie w `addEventListener`). 
Co to jest "Callback hell" (piekło wywołań zwrotnych)?;To sytuacja powstająca przy nadużywaniu callbacków, gdy trzeba łączyć wiele z nich w określonej, zależnej od siebie kolejności. Prowadzi to do głębokiego zagnieżdżenia kodu, który staje się nieczytelny i trudny w utrzymaniu. 
Czym w uproszczeniu jest **Promise** (Obietnica) w JavaScript?;To obiekt, który reprezentuje wartość, jaka może zostać wyprodukowana (zwrócona) w pewnym momencie w przyszłości (np. odpowiedź z zapytania do API).
Dlaczego przypisanie wyniku asynchronicznej funkcji bezpośrednio do zmiennej (np. `const data = getData()`) zazwyczaj skutkuje wartością `undefined`?;Ponieważ kod wykonuje się dalej bez czekania. Próba odczytania danych następuje, zanim asynchroniczna funkcja `getData()` zdąży je faktycznie pobrać i zwrócić.
Do czego służy metoda `.then()` wywoływana na obiekcie Promise?;Zatrzymuje ona wykonanie zawartego w niej kodu do momentu, aż Promise zostanie rozwiązany (resolved). Mówi programowi, aby poczekał na dane, a DOPIERO WTEDY (then) uruchomił na nich przekazaną funkcję.
Jaka jest składnia konstruktora obiektu Promise?;`new Promise(function(resolve, reject) { /* kod wykonawczy (executor) */ })`
Kiedy uruchamiana jest funkcja `executor` przekazana do konstruktora `new Promise`?;Automatycznie i natychmiastowo w momencie tworzenia obiektu Promise.
Jakie dwie **wewnętrzne właściwości** posiada obiekt Promise i jakie są ich wartości początkowe?;`state` (początkowo `"pending"`) oraz `result` (początkowo `undefined`). 
Jak zmieniają się właściwości `state` i `result` obiektu Promise po wywołaniu `resolve(value)`?;`state` zmienia się na `"fulfilled"`, a `result` zmienia się na przekazane `value`. 
Jak zmieniają się właściwości `state` i `result` obiektu Promise po wywołaniu `reject(error)`?;`state` zmienia się na `"rejected"`, a `result` zmienia się na przekazany `error`.
Co w kontekście Promise oznacza termin **"settled"** (rozstrzygnięty)?;Oznacza, że Promise zakończył działanie – nie jest już `"pending"`, lecz został spełniony (`"fulfilled"`) albo odrzucony (`"rejected"`).
Co się stanie, jeśli funkcja `executor` wywoła `resolve()` lub `reject()` wielokrotnie?;Tylko pierwsze wywołanie zostanie uwzględnione. Stan Promise po rozstrzygnięciu jest ostateczny, a wszelkie kolejne wywołania są ignorowane.
Jakie argumenty przyjmuje metoda `.then()`?;Przyjmuje dwie funkcje (callbacks): pierwsza uruchamia się przy sukcesie (otrzymuje wynik), a druga przy błędzie (otrzymuje obiekt błędu). Składnia: `.then(onFulfilled, onRejected)`.
Czym technicznie jest metoda `.catch(f)`?;Jest to dokładny odpowiednik i skrót (syntactic sugar) dla wywołania `.then(null, f)`.
Jakie są 3 główne cechy handlera w metodzie `.finally(f)`?;1. Nie przyjmuje żadnych argumentów (nie wie, czy zadanie zakończyło się sukcesem, czy błędem).<br>2. "Przepuszcza" (passes through) wynik lub błąd do kolejnego handlera w łańcuchu.<br>3. Zwracane przez niego wartości są ignorowane (wyjątkiem jest wyrzucenie błędu przez `throw`).
Co się stanie, jeśli przypniesz handlery (`.then`, `.catch`) do obiektu Promise, który już wcześniej został rozstrzygnięty (settled)?;Handlery te zostaną wykonane natychmiastowo z dostępnym już wynikiem.
Jakie są przewagi używania Promises w porównaniu do tradycyjnych Callbacks?;1. Naturalna kolejność (najpierw wywołanie asynchroniczne, potem określenie co zrobić z wynikiem przez `.then`).<br>2. Możliwość przypięcia wielu niezależnych handlerów do jednego obiektu Promise w dowolnym momencie.<br>3. Brak wymogu podawania funkcji zwrotnej (callback) z góry w momencie wywoływania funkcji asynchronicznej.
